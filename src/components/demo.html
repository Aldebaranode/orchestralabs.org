<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Demo</title>
  <style>
    .data-label {
      display: inline-block;
      width: 150px;
      font-weight: bold;
    }
    .data-value {
      display: inline-flex;
      min-width: 300px;
      max-width: 80%;
      overflow-x: auto;
    }
    .form-item {
      margin-bottom: 10px;
    }
    textarea {
      width: 100%;
      margin-bottom: 10px;
    }
    .container {
      display: flex;
    }
    .left, .right {
      flex: 1;
    }
    #ratioChartContainer {
      width: 100%;
      height: 250px;
      position: relative;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
      position: absolute;
    }
  </style>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    let timeStep = 0;
    let totalBlockCount = 0
    let currentExchangeRatio = 1; 
    let exchangeAddress = ''
    let reserveAddress = ''
    
    $(function () {
      // Fetch wallet data from server
      async function fetchDemoData() {
        $.ajax({
          url: '/demodata',
          type: 'GET',
          success: function (response) {
            $('#wallet_address').text(response['demo_address']);
            exchangeAddress = response['exchange_address'];
            reserveAddress = response['reserve_address'];
            $('#collateral_requirement').text(response['collateral_requirement']);
            currentExchangeRatio = response['exchange_ratio']

            updateRatioButtonsDisabledState();
          },
          error: function(error) {
            console.error('Error fetching wallet data:', error);
          }
        });
      }

      // Event listener for send money button
      async function sendMoney() {
        const confirmText = 'Are you sure to send?';
        let confirmResult = confirm(confirmText);
        if (confirmResult !== true) {
          alert('Canceled');
          return
        }

        const melody = {
          'name': 'Melody',
          'symbol': 'MLD',
          'type': 'OnChain',
        }
        const timeSent = Date.now()
        const transactionType = $('#transaction_type').val();
        const inputAsset = JSON.parse($('#sender_asset').val());
        const senderWalletAddress = $('#wallet_address').text();
        const outputAsset = JSON.parse($('#recipient_asset').val());
        const amount = parseFloat($('#send_amount').val());
        let recipientWalletAddress = $('#recipient_wallet_address').val();
        let exchangeWalletAddress = '';
        let feeStructure = {};

        if (transactionType === 'exchange') {
          const [exchangeQueryResult, feeQueryResult] = await Promise.all([
            fetch('/transactions/exchange').then(res => res.json()),
            fetch('/transactions/fees').then(res => res.json())
          ])
          exchangeWalletAddress = exchangeQueryResult.address
          feeStructure = feeQueryResult.fee_structure;
        } else {
          const feeQueryResult = await (await fetch('/transactions/fees')).json()
          feeStructure = feeQueryResult.fee_structure;
        }

        const transactionInput = {
          time_sent: timeSent,
          sender_wallet_address: senderWalletAddress,
          transaction_type: transactionType,
        };

        const transactionOutput = {
          recipient_wallet_address: transactionType === 'exchange' 
            ? exchangeWalletAddress 
            : recipientWalletAddress,
          asset: inputAsset,
          amount: amount,
        };

        // update fees by transaction amount
        for (let key in feeStructure) {
          feeStructure[key].asset = inputAsset;
          feeStructure[key].amount *= amount;
        }

        const transaction = {
          transaction_input: transactionInput,
          transaction_output: transactionOutput,
          transaction_fees: feeStructure,
        };
        const senderPrivateKey = $('#private_key').val();
        const senderPublicKey = $('#public_key').val();

        // Create UnsignedTransactionRequest struct
        let dataPackage = { transaction, sender_private_key: senderPrivateKey, sender_public_key: senderPublicKey };
        let endpoint = '/transactions';

        if (transactionType === 'exchange') {
          endpoint = '/transactions/exchange';

          const exchangeOutput = {
            recipient_wallet_address: recipientWalletAddress,
            asset: outputAsset,
            amount: null,
          };

          // Create UnsignedExchangeRequest struct
          dataPackage = { exchange_output: exchangeOutput, unsigned_transaction_request: dataPackage };
        }
      
        $.ajax({
          url: endpoint,
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify(dataPackage),
          success: function (response) {
            console.info(response);
            if (response.message == 'fail') {
              alert('Transaction failed');
            } else {
              alert('Transaction successful');
            }
          },
          error: function (response) {
            console.error(response);
            alert('Transaction failed');
          }
        });
      }

      // Function to reload wallet balance
      function reloadWalletBalance() {
        let data = {'wallet_address': $('#wallet_address').text()};
        console.log('Wallet Address:', data); // Debugging log

        $.ajax({
          url: '/wallets/balance',
          type: 'GET',
          data: data,
          success: function (response) {
            let totalAmounts = response['total_amounts'];
            processWalletAmounts(totalAmounts, '#asset_amounts', null, null);
          },
          error: function(error) {
            console.error('Error fetching wallet data:', error);
          }
        });
      }

      let ctx = document.getElementById('ratioChart').getContext('2d');
      let ratioChart = new Chart(ctx, {
          type: 'line',
          data: {
              labels: [],
              datasets: [{
                  label: 'Exchange Balance to Collateral Ratio',
                  backgroundColor: 'rgba(255, 99, 132, 0.2)',
                  borderColor: 'rgba(255, 99, 132, 1)',
                  data: []
              },
              {
                  label: 'Reserve Balance to Collateral Ratio',
                  backgroundColor: 'rgba(54, 162, 235, 0.2)',
                  borderColor: 'rgba(54, 162, 235, 1)',
                  data: []
              },
            ],
          },
          options: {
              scales: {
                y: {
                  beginAtZero: true,
                  suggestedMax: 100,
                  ticks: {
                      stepSize: 25
                  }
              }
              }
          }
      });

      function updateRatioChart(newTimestamp, newExchangeRatio, newReserveRatio) {
        // Find the index of the existing timestamp
        const timestampIndex = ratioChart.data.labels.findIndex(timestamp => timestamp === newTimestamp);

        if (timestampIndex !== -1) {
          // Update data at the found index
          ratioChart.data.datasets[0].data[timestampIndex] = newExchangeRatio; // Update exchange dataset
          ratioChart.data.datasets[1].data[timestampIndex] = newReserveRatio; // Update reserve dataset
        } else {
          // Add new data
          ratioChart.data.labels.push(newTimestamp);
          ratioChart.data.datasets[0].data.push(newExchangeRatio); // Update exchange dataset
          ratioChart.data.datasets[1].data.push(newReserveRatio); // Update reserve dataset
        }

        ratioChart.update();
      }

      async function reloadExchangeInfo() {
        // Fetch exchange address
        await fetchDemoData();

        try {
          const exchangeWalletAddress = exchangeAddress;
          const reserveWalletAddress = reserveAddress;
          const collateralRequirement = Number($('#collateral_requirement').text());

          let exchangeCollateralPercent = 0; // Initialize to 0
          let reserveCollateralPercent = 0; // Initialize to 0

          // Fetch and process exchange balance
          let exchangeData = {'wallet_address': exchangeWalletAddress};
          const exchangeResponse = await $.ajax({
            url: '/wallets/balance',
            type: 'GET',
            data: exchangeData
          });

          // Fetch and process reserve balance
          let reserveData = {'wallet_address': reserveWalletAddress};
          const reserveResponse = await $.ajax({
            url: '/wallets/balance',
            type: 'GET',
            data: reserveData
          });

          let exchangeTotalAmounts = exchangeResponse['total_amounts'];
          let exchangeAmount = processWalletAmounts(exchangeTotalAmounts, '#exchange_balances', 'Melody');
          exchangeCollateralPercent = (collateralRequirement === 0) ? 100 : Math.min((exchangeAmount / collateralRequirement) * 100, 100);

          let reserveTotalAmounts = reserveResponse['total_amounts'];
          let reserveAmount = processWalletAmounts(reserveTotalAmounts, '#reserve_balances', 'Melody');
          reserveCollateralPercent = (collateralRequirement === 0) ? 100 : Math.min((reserveAmount / collateralRequirement) * 100, 100);

          // Update chart
          updateRatioChart(totalBlockCount, exchangeCollateralPercent, reserveCollateralPercent);
        } catch (error) {
          console.error('Error fetching exchange info:', error);
        }
      }

      function processWalletAmounts(totalAmounts, divId, targetAssetName) {
        let assetAmountsDiv = $(divId);
        assetAmountsDiv.empty();

        let assetsFound = false; // Flag to check if we have assets with balances greater than 0

        if (totalAmounts && Object.keys(totalAmounts).length > 0) {
          let assetAmountFound = 0;

          Object.keys(totalAmounts).forEach(assetJSON => {
            let asset = JSON.parse(assetJSON);
            let assetName = asset['name'];
            let assetSymbol = asset['symbol'];
            let assetAmount = totalAmounts[assetJSON];

            // Only add to display if the amount is greater than 0
            if (assetAmount > 0) {
              assetsFound = true;
              assetAmountsDiv.append('<p>' + assetName + ' (' + assetSymbol + '): ' + assetAmount + '</p>');
              if (assetName === targetAssetName) {
                assetAmountFound = assetAmount;
              }
            }
          });

          if (!assetsFound) {
            assetAmountsDiv.text("EMPTY");
          }

          return assetAmountFound;
        } else {
          assetAmountsDiv.text("EMPTY");
          return 0;
        }
      }

      async function fetchBlockchainData() {
        // Replace with your actual AJAX call to fetch blockchain data
        $.ajax({
          url: '/blockchainData',
          type: 'GET',
          success: function (response) {
              // Format the response as JSON with indentation for readability
              let formattedJSON = JSON.stringify(response, null, 4);

              // Update the totalBlockCount based on the response
              if (response && response.blockchain) {
                  totalBlockCount = response.blockchain.length;
              }
          },
          error: function(error) {
              console.error('Error fetching blockchain data:', error);
          }
        });
      }

      function changeExchangeRatio(newRatio) {
        $.ajax({
          url: `/changeExchangeRatio?percentage=${newRatio}`,
          type: 'POST',
          success: function(response) {
              console.info(`Exchange ratio changed to ${newRatio}%`, response);
              alert(`Exchange ratio changed to ${newRatio}%`);

              currentExchangeRatio = newRatio / 100;
          },
        });
      }

      async function updateMaxSendableAmount() {
        const walletAddress = $('#wallet_address').text();
        if (!walletAddress) return; // No wallet address, skip update

        // Fetch current wallet balance
        let walletBalanceResponse = await fetch(`/wallets/balance?wallet_address=${walletAddress}`).then(res => res.json());
        let melodyBalance = processWalletAmounts(walletBalanceResponse['total_amounts'], null, 'Melody') || 0;

        // Fetch current transaction fees (as percentages)
        let feeResponse = await fetch('/transactions/fees').then(res => res.json());
        let minerFeePercent = feeResponse.fee_structure.miner_fee.amount;
        let reserveFeePercent = feeResponse.fee_structure.reserve_fee.amount;
        $('#current_fees').text(`Current Fees - Miner Fee: ${minerFeePercent * 100}%, Reserve Fee: ${reserveFeePercent * 100}%`);

        // Calculate total fee factor (1 + sum of fee percentages)
        let totalFeeFactor = 1 + minerFeePercent + reserveFeePercent;

        // Calculate maximum sendable amount before fees
        let maxAmountsText = 'Maximum Sendable Amounts: ';
        for (const [assetJSON, balance] of Object.entries(walletBalanceResponse['total_amounts'])) {
          let asset = JSON.parse(assetJSON);
          let maxSendableAmountBeforeFees = balance / totalFeeFactor;
          maxAmountsText += `${asset.name}: ${maxSendableAmountBeforeFees.toFixed(2)} `;
        }

        $('#max_amounts').text(maxAmountsText.trim());

        calculateAndDisplayFees()
        displayExpectedReturn()
      }

      async function calculateAndDisplayFees() {
        let amountToSend = parseFloat($('#send_amount').val());
        if (isNaN(amountToSend) || amountToSend <= 0) {
          $('#estimated_fees').text('Estimated Fees: N/A');
          return;
        }

        // Fetch current transaction fees (as percentages)
        let feeResponse = await fetch('/transactions/fees').then(res => res.json());
        let minerFeePercent = feeResponse.fee_structure.miner_fee.amount;
        let reserveFeePercent = feeResponse.fee_structure.reserve_fee.amount;

        let selectedAsset = JSON.parse($('#sender_asset').val());
        let symbol = selectedAsset.symbol;

        // Calculate fees
        let minerFee = amountToSend * minerFeePercent;
        let reserveFee = amountToSend * reserveFeePercent;
        let totalFees = minerFee + reserveFee;

        // Display the fees
        $('#estimated_fees').text(`Estimated Fees - Miner Fee: ${minerFee.toFixed(2)} ${symbol}, Reserve Fee: ${reserveFee.toFixed(2)} ${symbol}, Total Fees: ${totalFees.toFixed(2)} ${symbol}`);
      }

      function adjustAssetSelections() {
        let transactionType = $('#transaction_type').val();
        let senderAsset = $('#sender_asset').val();
        let recipientAsset = $('#recipient_asset').val();

        // If transaction type is 'exchange', ensure assets are different
        if (transactionType === 'exchange') {
          if (senderAsset === recipientAsset) {
            // Change the recipient asset to a different option
            $('#recipient_asset option').each(function() {
              if ($(this).val() !== senderAsset) {
                $('#recipient_asset').val($(this).val());
                return false; // break the loop
              }
            });
          }
        }
      }

      function displayExpectedReturn() {
        const amountToSend = parseFloat($('#send_amount').val());
        const transactionType = $('#transaction_type').val();
        let expectedSymbol = JSON.parse($('#sender_asset').val()).symbol; // Default to sender asset symbol for transfers

        if (transactionType === 'exchange') {
          expectedSymbol = JSON.parse($('#recipient_asset').val()).symbol; // Use recipient asset symbol for exchanges
        }

        if (!isNaN(amountToSend) && amountToSend > 0) {
          let expectedReturnAmount = amountToSend;

          if (transactionType === 'exchange') {
            expectedReturnAmount = amountToSend * currentExchangeRatio; // Apply exchange ratio for exchanges
          }

          $('#expected_return').text(`Expected Return: ${expectedReturnAmount.toFixed(2)} ${expectedSymbol}`);
        } else {
          $('#expected_return').text('Expected Return: N/A');
        }
      }

      function updateRecipientAsset() {
        const transactionType = $('#transaction_type').val();
        if (transactionType === 'transfer') {
          // Set recipient asset to the same as sender asset and make it disabled
          const senderAsset = $('#sender_asset').val();
          $('#recipient_asset').val(senderAsset).prop('disabled', true);
        } else {
          // Enable the recipient asset dropdown for exchanges
          $('#recipient_asset').prop('disabled', false);
        }
      }

      function updateRatioButtonsDisabledState() {
        $('.change-ratio-button').each(function() {
          const ratioValue = $(this).data('change-ratio');
          if (ratioValue === currentExchangeRatio * 100) {
            $(this).prop('disabled', true); // Disable the button matching the current ratio
          } else {
            $(this).prop('disabled', false); // Enable all other buttons
          }
        });
      }

      $('.change-ratio-button').on('click', function() {
        const newRatio = $(this).data('change-ratio');
        changeExchangeRatio(newRatio);
        updateRatioButtonsDisabledState();
      });

      // Attach event handler to the send button
      $('#send_money_button').on('click', async function() {
        await sendMoney();
        $('#send_amount').val("");
        updateMaxSendableAmount()
      });

      $('#send_amount').on('input', function() {
        calculateAndDisplayFees();
        displayExpectedReturn();
      });

      $('#transaction_type').on('change', function() {
        updateRecipientAsset();
        adjustAssetSelections();
        displayExpectedReturn();
      });

      // Event listener for changes in the sender asset
      $('#sender_asset').on('change', function() {
        updateRecipientAsset();
        adjustAssetSelections();
      });

      // Event listener for changes in the recipient asset
      $('#recipient_asset').on('change', function() {
        adjustAssetSelections();
      });

      // Initial data fetch
      fetchDemoData();
      fetchBlockchainData();
      updateMaxSendableAmount()
      calculateAndDisplayFees();
      adjustAssetSelections();
      displayExpectedReturn();
      updateRecipientAsset();
      updateRatioButtonsDisabledState();

      // Set repeating actions
      setInterval(reloadWalletBalance, 3000); 
      setInterval(reloadExchangeInfo, 3000);
      setInterval(updateMaxSendableAmount, 3000);
      setInterval(fetchBlockchainData, 15000);
    })
  </script>
</head>
<body>
  <div>
    <div class="container">
      <div class="left">
        <div>
          <h1>Demo Wallet</h1>
          <p>Note: Data refreshes every 3 second(s). A new block is created every 1 minute(s).</p>
          <div>
            <span class="data-label">Wallet Address:</span> <span id="wallet_address" class="data-value"></span><br>
            <span class="data-label">Wallet Balances:</span> <span id="asset_amounts" class="data-value"></span><br>
            <span class="data-label">Exchange Balances:</span> <span id="exchange_balances" class="data-value"></span><br>
            <span class="data-label">Reserve Balances:</span> <span id="reserve_balances" class="data-value"></span><br>
            <span class="data-label">Collateral Requirement:</span> <span id="collateral_requirement" class="data-value"></span><br>
          </div>
        </div>
        
        <div>
          <h1>Send Money / Exchange</h1>
          <p id="current_fees">Current Fees: Loading...</p>
          <p id="max_amounts">Maximum Sendable Amounts: Loading...</p>

          <div class="form-item">
            <label>Transaction Type</label>
            <select id="transaction_type">
              <option value="transfer">Transfer</option>
              <option value="exchange">Exchange</option>
            </select>
          </div>
      
          <div class="form-item">
            <label>Sender Asset</label>
            <select id="sender_asset">
              <option value='{"name": "Melody", "symbol": "MLD", "type": "On_Chain"}'>Melody</option>
              <option value='{"name": "Harmony USD", "symbol": "HUSD", "type": "Harmony"}'>HUSD</option>
            </select>
          </div>
      
          <div class="form-item">
            <label>Recipient Asset</label>
            <select id="recipient_asset">
              <option value='{"name": "Melody", "symbol": "MLD", "type": "On_Chain"}'>Melody</option>
              <option value='{"name": "Harmony USD", "symbol": "HUSD", "type": "Harmony"}'>HUSD</option>
            </select>
          </div>
      
          <input class="form-item" id="recipient_wallet_address" type="text" placeholder="Recipient Address">
          <input class="form-item" id="send_amount" type="text" placeholder="Amount">
          <p id="estimated_fees">Estimated Fees: N/A</p>
          <p id="expected_return">Expected Return: N/A</p>
          <button id="send_money_button">Send / Exchange</button>
        </div>
      </div>

      <div class="right">
        <div>
          <h2>Exchange Ratio (MLD:HUSD)</h2>
          <button class="change-ratio-button" data-change-ratio="100">1:1</button>
          <button class="change-ratio-button" data-change-ratio="75">3:4</button>
          <button class="change-ratio-button" data-change-ratio="50">1:2</button>
          <button class="change-ratio-button" data-change-ratio="25">1:4</button>
        </div>

        <h3>Percent Collateral Met by Block Height</h3>
        <div id="ratioChartContainer">
          <canvas id="ratioChart"></canvas> 
        </div>
      </div>
    </div>
</body>
</html>